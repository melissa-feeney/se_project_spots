(self.webpackJsonp_N_E=self.webpackJsonp_N_E||[]).push([[12],{"L++b":function(e,t,o){"use strict";(function(e){var r=o("Dlk0"),n=o("cFGl");Object.defineProperty(t,"__esModule",{value:!0}),t.MatrixClient=x,t.CRYPTO_ENABLED=void 0;var i=n(o("ly6l")),s=o("hBZP"),c=o("QJ+M"),a=o("uHjp"),u=o("2syV"),d=o("MwLI"),p=o("apMS"),l=o("fWms"),h=o("zoGq"),y=o("/0WT"),g=o("QjTS"),f=r(o("dZ+v")),m=o("lWzV"),_=o("IAeZ"),v=r(o("gl1w")),E=r(o("n/Lb")),S=o("3Qxt"),k=o("du21"),I=o("uZMU"),w=o("eNVr"),R=o("eH6s"),b=o("Yh/a"),T=o("ns36"),P=o("Lk+r"),U=o("D67U"),C=o("vlvg"),D=o("DLQN");const K=(0,w.isCryptoAvailable)();t.CRYPTO_ENABLED=K;const A=6e5;function $(e,t,o){const r=[];for(const[i,s]of Object.entries(e))try{const e=q(s,t);e.session_id=i,e.room_id=o,r.push(e)}catch(n){I.logger.log("Failed to decrypt megolm session from backup",n)}return r}function q(e,t){return JSON.parse(t.decrypt(e.session_data.ephemeral,e.session_data.mac,e.session_data.ciphertext))}function x(e){e.baseUrl=f.ensureNoTrailingSlash(e.baseUrl),e.idBaseUrl=f.ensureNoTrailingSlash(e.idBaseUrl),c.MatrixBaseApis.call(this,e),this.olmVersion=null,this.reEmitter=new S.ReEmitter(this),this.usingExternalCrypto=e.usingExternalCrypto,this.store=e.store||new h.StubStore,this.deviceId=e.deviceId||null;const t=e.userId||null;if(this.credentials={userId:t},e.deviceToImport?this.deviceId?I.logger.warn("not importing device because device ID is provided to constructor independently of exported data"):this.credentials.userId?I.logger.warn("not importing device because user ID is provided to constructor independently of exported data"):e.deviceToImport.deviceId?(this.deviceId=e.deviceToImport.deviceId,this.credentials.userId=e.deviceToImport.userId,this._exportedOlmDeviceToImport=e.deviceToImport.olmDevice):I.logger.warn("not importing device because no device ID in exported data"):e.pickleKey&&(this.pickleKey=e.pickleKey),this.scheduler=e.scheduler,this.scheduler){const e=this;this.scheduler.setProcessFunction((async function(t){const o=e.getRoom(t.getRoomId());t.status!==d.EventStatus.SENDING&&F(o,t,d.EventStatus.SENDING);const r=await N(e,t);return o&&o.updatePendingEvent(t,d.EventStatus.SENT,r.event_id),r}))}this.clientRunning=!1;const o=(0,y.createNewMatrixCall)(this);this._supportsVoip=!1,o?(this._callEventHandler=new g.CallEventHandler(this),this._supportsVoip=!0):this._callEventHandler=null,this._syncingRetry=null,this._syncApi=null,this._peekSync=null,this._isGuest=!1,this._ongoingScrollbacks={},this.timelineSupport=Boolean(e.timelineSupport),this.urlPreviewCache={},this._notifTimelineSet=null,this.unstableClientRelationAggregation=!!e.unstableClientRelationAggregation,this._crypto=null,this._cryptoStore=e.cryptoStore,this._sessionStore=e.sessionStore,this._verificationMethods=e.verificationMethods,this._cryptoCallbacks=e.cryptoCallbacks||{},this._forceTURN=e.forceTURN||!1,this._iceCandidatePoolSize=void 0===e.iceCandidatePoolSize?0:e.iceCandidatePoolSize,this._supportsCallTransfer=e.supportsCallTransfer||!1,this._fallbackICEServerAllowed=e.fallbackICEServerAllowed||!1,this._roomList=new k.RoomList(this._cryptoStore),this._pushProcessor=new P.PushProcessor(this),this._serverVersionsPromise=null,this._cachedCapabilities=null,this._clientWellKnown=void 0,this._clientWellKnownPromise=void 0,this._turnServers=[],this._turnServersExpiry=0,this._checkTurnServersIntervalID=null,this.on("Event.decrypted",(e=>{const t=e.getPushActions(),o=this._pushProcessor.actionsForEvent(e);e.setPushActions(o);const r=this.getRoom(e.getRoomId());if(!r)return;const n=r.getUnreadNotificationCount("highlight"),i=!(!t||!t.tweaks)&&!!t.tweaks.highlight,s=!(!o||!o.tweaks)&&!!o.tweaks.highlight;if((i!==s||n>0)&&!r.hasUserReadEvent(this.getUserId(),e.getId())){let e=n;s&&!i&&e++,!s&&i&&e--,r.setUnreadNotificationCount("highlight",e);r.getUnreadNotificationCount("total")<e&&r.setUnreadNotificationCount("total",e)}})),this.on("Room.receipt",((e,t)=>{if(t&&this.isRoomEncrypted(t.roomId)){const o=e.getContent();if(!(Object.keys(o).filter((e=>Object.keys(o[e]["m.read"]).includes(this.getUserId()))).length>0))return;const r=20,n=t.getLiveTimeline().getEvents();let i=0;for(let e=n.length-1;e>=0;e--){if(e===n.length-r)return;const o=n[e];if(t.hasUserReadEvent(this.getUserId(),o.getId()))break;const s=this.getPushActionsForEvent(o);i+=s.tweaks&&s.tweaks.highlight?1:0}t.setUnreadNotificationCount("highlight",i)}}))}async function O(e,t,o,r,n,i){if(!e._crypto)throw new Error("End-to-End encryption disabled");await e._crypto.setDeviceVerification(t,o,r,n,i)}function B(e,t){for(const o of t)e.prototype[o]=function(...e){if(!this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto[o](...e)}}function M(e,t,o,r){return Promise.resolve().then((function(){const r=function(e,t,o){if(t.isEncrypted())return null;if(!e.isRoomEncrypted(t.getRoomId()))return null;if(!e._crypto&&e.usingExternalCrypto)return null;if("m.reaction"===t.getType())return null;if(!e._crypto)throw new Error("This room is configured to use encryption, but your client does not support encryption.");return e._crypto.encryptEvent(t,o)}(e,o,t);return r?(F(t,o,d.EventStatus.ENCRYPTING),r.then((()=>{F(t,o,d.EventStatus.SENDING)}))):null})).then((function(){let r;return e.scheduler&&(r=e.scheduler.queueEvent(o),r&&e.scheduler.getQueueForEvent(o).length>1&&F(t,o,d.EventStatus.QUEUED)),r||(r=N(e,o),t&&(r=r.then((e=>(t.updatePendingEvent(o,d.EventStatus.SENT,e.event_id),e))))),r})).then((function(e){return r&&r(null,e),e}),(function(e){I.logger.error("Error sending event",e.stack||e);try{o.error=e,F(t,o,d.EventStatus.NOT_SENT),e.event=o,r&&r(e)}catch(n){I.logger.error("Exception in error handler!",n.stack||e)}throw e}))}function F(e,t,o){e?e.updatePendingEvent(t,o):t.setStatus(o)}function N(e,t){let o=t.getTxnId();o||(o=e.makeTxnId(),t.setTxnId(o));const r={$roomId:t.getRoomId(),$eventType:t.getWireType(),$stateKey:t.getStateKey(),$txnId:o};let n;if(t.isState()){let e="/rooms/$roomId/state/$eventType";t.getStateKey()&&t.getStateKey().length>0&&(e="/rooms/$roomId/state/$eventType/$stateKey"),n=f.encodeUri(e,r)}else if(t.isRedaction()){const e="/rooms/$roomId/redact/$redactsEventId/$txnId";n=f.encodeUri(e,Object.assign({$redactsEventId:t.event.redacts},r))}else n=f.encodeUri("/rooms/$roomId/send/$eventType/$txnId",r);return e._http.authedRequest(void 0,"PUT",n,void 0,t.getWireContent()).then((e=>(I.logger.log(`Event sent to ${t.getRoomId()} with event id ${e.event_id}`),e)))}function L(e,t,o,r,n,i){f.isFunction(n)&&(i=n,n=void 0);const s=f.encodeUri("/rooms/$room_id/$membership",{$room_id:t,$membership:r});return e._http.authedRequest(i,"POST",s,void 0,{user_id:o,reason:n})}function G(e,t,o){e&&e(o),t(o)}function V(e,t,o){e&&e(null,o),t(o)}function j(e,t){const o=Boolean(t&&t.preventReEmit);return function(t){const r=new d.MatrixEvent(t);return r.isEncrypted()&&(o||e.reEmitter.reEmit(r,["Event.decrypted"]),r.attemptDecryption(e._crypto)),o||e.reEmitter.reEmit(r,["Event.replaced"]),r}}f.inherits(x,s.EventEmitter),f.extend(x.prototype,c.MatrixBaseApis.prototype),x.prototype.rehydrateDevice=async function(){if(this._crypto)throw new Error("Cannot rehydrate device after crypto is initialized");if(!this._cryptoCallbacks.getDehydrationKey)return;const t=this.getDehydratedDevice();if(!t)return;if(!t.device_data||!t.device_id)return void I.logger.info("no dehydrated device found");const o=new e.Olm.Account;try{const e=t.device_data;if(e.algorithm!==D.DEHYDRATION_ALGORITHM)return void I.logger.warn("Wrong algorithm for dehydrated device");I.logger.log("unpickling dehydrated device");const r=await this._cryptoCallbacks.getDehydrationKey(e,(t=>{o.unpickle(new Uint8Array(t),e.account)}));o.unpickle(r,e.account),I.logger.log("unpickled device");if(!0===(await this._http.authedRequest(void 0,"POST","/dehydrated_device/claim",void 0,{device_id:t.device_id},{prefix:"/_matrix/client/unstable/org.matrix.msc2697.v2"})).success){this.deviceId=t.device_id,I.logger.info("using dehydrated device");const e=this.pickleKey||"DEFAULT_KEY";return this._exportedOlmDeviceToImport={pickledAccount:o.pickle(e),sessions:[],pickleKey:e},o.free(),this.deviceId}return o.free(),void I.logger.info("not using dehydrated device")}catch(r){o.free(),I.logger.warn("could not unpickle",r)}},x.prototype.getDehydratedDevice=async function(){try{return await this._http.authedRequest(void 0,"GET","/dehydrated_device",void 0,void 0,{prefix:"/_matrix/client/unstable/org.matrix.msc2697.v2"})}catch(e){return void I.logger.info("could not get dehydrated device",e.toString())}},x.prototype.setDehydrationKey=async function(e,t={},o){if(this._crypto)return await this._crypto._dehydrationManager.setKeyAndQueueDehydration(e,t,o);I.logger.warn("not dehydrating device if crypto is not enabled")},x.prototype.createDehydratedDevice=async function(e,t={},o){if(this._crypto)return await this._crypto._dehydrationManager.setKey(e,t,o),await this._crypto._dehydrationManager.dehydrateDevice();I.logger.warn("not dehydrating device if crypto is not enabled")},x.prototype.exportDevice=async function(){if(this._crypto)return{userId:this.credentials.userId,deviceId:this.deviceId,olmDevice:await this._crypto._olmDevice.export()};I.logger.warn("not exporting device if crypto is not enabled")},x.prototype.clearStores=function(){if(this._clientRunning)throw new Error("Cannot clear stores while client is running");const e=[];return e.push(this.store.deleteAllData()),this._cryptoStore&&e.push(this._cryptoStore.deleteAllData()),Promise.all(e)},x.prototype.getUserId=function(){return this.credentials&&this.credentials.userId?this.credentials.userId:null},x.prototype.getDomain=function(){return this.credentials&&this.credentials.userId?this.credentials.userId.replace(/^.*?:/,""):null},x.prototype.getUserIdLocalpart=function(){return this.credentials&&this.credentials.userId?this.credentials.userId.split(":")[0].substring(1):null},x.prototype.getDeviceId=function(){return this.deviceId},x.prototype.supportsVoip=function(){return this._supportsVoip},x.prototype.setForceTURN=function(e){this._forceTURN=e},x.prototype.setSupportsCallTransfer=function(e){this._supportsCallTransfer=e},x.prototype.getSyncState=function(){return this._syncApi?this._syncApi.getSyncState():null},x.prototype.getSyncStateData=function(){return this._syncApi?this._syncApi.getSyncStateData():null},x.prototype.isInitialSyncComplete=function(){const e=this.getSyncState();return!!e&&("PREPARED"===e||"SYNCING"===e)},x.prototype.isGuest=function(){return this._isGuest},x.prototype.getScheduler=function(){return this.scheduler},x.prototype.setGuest=function(e){this._isGuest=e},x.prototype.retryImmediately=function(){return this._syncApi.retryImmediately()},x.prototype.getNotifTimelineSet=function(){return this._notifTimelineSet},x.prototype.setNotifTimelineSet=function(e){this._notifTimelineSet=e},x.prototype.getCapabilities=function(e=!1){const t=(new Date).getTime();return this._cachedCapabilities&&!e&&t<this._cachedCapabilities.expiration?(I.logger.log("Returning cached capabilities"),Promise.resolve(this._cachedCapabilities.capabilities)):this._http.authedRequest(void 0,"GET","/capabilities").catch((e=>(I.logger.error(e),null))).then((e=>{e||(e={});const o=e.capabilities||{},r=Object.keys(o).length?216e5:6e4+5e3*Math.random();return this._cachedCapabilities={capabilities:o,expiration:t+r},I.logger.log("Caching capabilities: ",o),o}))},x.prototype.initCrypto=async function(){if(!(0,w.isCryptoAvailable)())throw new Error("End-to-end encryption not supported in this js-sdk build: did you remember to load the olm library?");if(this._crypto)return void I.logger.warn("Attempt to re-initialise e2e encryption on MatrixClient");if(!this._sessionStore)throw new Error("Cannot enable encryption: no sessionStore provided");if(!this._cryptoStore)throw new Error("Cannot enable encryption: no cryptoStore provided");I.logger.log("Crypto: Starting up crypto store..."),await this._cryptoStore.startup(),I.logger.log("Crypto: initialising roomlist..."),await this._roomList.init();const e=this.getUserId();if(null===e)throw new Error("Cannot enable encryption on MatrixClient with unknown userId: ensure userId is passed in createClient().");if(null===this.deviceId)throw new Error("Cannot enable encryption on MatrixClient with unknown deviceId: ensure deviceId is passed in createClient().");const t=new w.Crypto(this,this._sessionStore,e,this.deviceId,this.store,this._cryptoStore,this._roomList,this._verificationMethods);this.reEmitter.reEmit(t,["crypto.keyBackupFailed","crypto.keyBackupSessionsRemaining","crypto.roomKeyRequest","crypto.roomKeyRequestCancellation","crypto.warning","crypto.devicesUpdated","crypto.willUpdateDevices","deviceVerificationChanged","userTrustStatusChanged","crossSigning.keysChanged"]),I.logger.log("Crypto: initialising crypto object..."),await t.init({exportedOlmDevice:this._exportedOlmDeviceToImport,pickleKey:this.pickleKey}),delete this._exportedOlmDeviceToImport,this.olmVersion=w.Crypto.getOlmVersion(),t.registerEventHandlers(this),this._crypto=t},x.prototype.isCryptoEnabled=function(){return null!==this._crypto},x.prototype.getDeviceEd25519Key=function(){return this._crypto?this._crypto.getDeviceEd25519Key():null},x.prototype.getDeviceCurve25519Key=function(){return this._crypto?this._crypto.getDeviceCurve25519Key():null},x.prototype.uploadKeys=function(){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.uploadDeviceKeys()},x.prototype.downloadKeys=function(e,t){return null===this._crypto?Promise.reject(new Error("End-to-end encryption disabled")):this._crypto.downloadKeys(e,t)},x.prototype.getStoredDevicesForUser=function(e){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.getStoredDevicesForUser(e)||[]},x.prototype.getStoredDevice=function(e,t){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.getStoredDevice(e,t)||null},x.prototype.setDeviceVerified=function(e,t,o){void 0===o&&(o=!0);const r=O(this,e,t,o,null);return e==this.credentials.userId&&this._crypto.checkKeyBackup(),r},x.prototype.setDeviceBlocked=function(e,t,o){return void 0===o&&(o=!0),O(this,e,t,null,o)},x.prototype.setDeviceKnown=function(e,t,o){return void 0===o&&(o=!0),O(this,e,t,null,null,o)},x.prototype.requestVerificationDM=function(e,t){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.requestVerificationDM(e,t)},x.prototype.findVerificationRequestDMInProgress=function(e){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.findVerificationRequestDMInProgress(e)},x.prototype.getVerificationRequestsToDeviceInProgress=function(e){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.getVerificationRequestsToDeviceInProgress(e)},x.prototype.requestVerification=function(e,t){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.requestVerification(e,t)},x.prototype.beginKeyVerification=function(e,t,o){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.beginKeyVerification(e,t,o)},x.prototype.setGlobalBlacklistUnverifiedDevices=function(e){if(null===this._crypto)throw new Error("End-to-end encryption disabled");this._crypto.setGlobalBlacklistUnverifiedDevices(e)},x.prototype.getGlobalBlacklistUnverifiedDevices=function(){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.getGlobalBlacklistUnverifiedDevices()},x.prototype.setGlobalErrorOnUnknownDevices=function(e){if(null===this._crypto)throw new Error("End-to-end encryption disabled");this._crypto.setGlobalErrorOnUnknownDevices(e)},x.prototype.getGlobalErrorOnUnknownDevices=function(){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.getGlobalErrorOnUnknownDevices()},B(x,["getCrossSigningId","getStoredCrossSigningForUser","checkUserTrust","checkDeviceTrust","checkOwnCrossSigningTrust","checkCrossSigningPrivateKey","legacyDeviceVerification","prepareToEncrypt","isCrossSigningReady","bootstrapCrossSigning","getCryptoTrustCrossSignedDevices","setCryptoTrustCrossSignedDevices","countSessionsNeedingBackup"]),B(x,["getEventEncryptionInfo","createRecoveryKeyFromPassphrase","isSecretStorageReady","bootstrapSecretStorage","addSecretStorageKey","hasSecretStorageKey","storeSecret","getSecret","isSecretStored","requestSecret","getDefaultSecretStorageKeyId","setDefaultSecretStorageKeyId","checkSecretStorageKey","checkSecretStoragePrivateKey"]),x.prototype.getEventSenderDeviceInfo=async function(e){return this._crypto?this._crypto.getEventSenderDeviceInfo(e):null},x.prototype.isEventSenderVerified=async function(e){const t=await this.getEventSenderDeviceInfo(e);return!!t&&t.isVerified()},x.prototype.cancelAndResendEventRoomKeyRequest=function(e){return e.cancelAndResendKeyRequest(this._crypto,this.getUserId())},x.prototype.setRoomEncryption=function(e,t){if(!this._crypto)throw new Error("End-to-End encryption disabled");return this._crypto.setRoomEncryption(e,t)},x.prototype.isRoomEncrypted=function(e){const t=this.getRoom(e);if(!t)return!1;return!!t.currentState.getStateEvents("m.room.encryption","")||this._roomList.isRoomEncrypted(e)},x.prototype.forceDiscardSession=function(e){if(!this._crypto)throw new Error("End-to-End encryption disabled");this._crypto.forceDiscardSession(e)},x.prototype.exportRoomKeys=function(){return this._crypto?this._crypto.exportRoomKeys():Promise.reject(new Error("End-to-end encryption disabled"))},x.prototype.importRoomKeys=function(e,t){if(!this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.importRoomKeys(e,t)},x.prototype.checkKeyBackup=function(){return this._crypto.checkKeyBackup()},x.prototype.getKeyBackupVersion=function(){return this._http.authedRequest(void 0,"GET","/room_keys/version",void 0,void 0,{prefix:m.PREFIX_UNSTABLE}).then((e=>{if(e.algorithm!==E.MEGOLM_BACKUP_ALGORITHM){const t="Unknown backup algorithm: "+e.algorithm;return Promise.reject(t)}if("object"===typeof e.auth_data&&e.auth_data.public_key)return e;{const e="Invalid backup data returned";return Promise.reject(e)}})).catch((e=>{if("M_NOT_FOUND"===e.errcode)return null;throw e}))},x.prototype.isKeyBackupTrusted=function(e){return this._crypto.isKeyBackupTrusted(e)},x.prototype.getKeyBackupEnabled=function(){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto._checkedForBackup?Boolean(this._crypto.backupKey):null},x.prototype.enableKeyBackup=function(t){if(null===this._crypto)throw new Error("End-to-end encryption disabled");this._crypto.backupInfo=t,this._crypto.backupKey&&this._crypto.backupKey.free(),this._crypto.backupKey=new e.Olm.PkEncryption,this._crypto.backupKey.set_recipient_key(t.auth_data.public_key),this.emit("crypto.keyBackupStatus",!0),this._crypto.scheduleKeyBackupSend()},x.prototype.disableKeyBackup=function(){if(null===this._crypto)throw new Error("End-to-end encryption disabled");this._crypto.backupInfo=null,this._crypto.backupKey&&this._crypto.backupKey.free(),this._crypto.backupKey=null,this.emit("crypto.keyBackupStatus",!1)},x.prototype.prepareKeyBackupVersion=async function(e,{secureSecretStorage:t=!1}={}){if(null===this._crypto)throw new Error("End-to-end encryption disabled");const{keyInfo:o,encodedPrivateKey:r,privateKey:n}=await this.createRecoveryKeyFromPassphrase(e);t&&(await this.storeSecret("m.megolm_backup.v1",(0,E.encodeBase64)(n)),I.logger.info("Key backup private key stored in secret storage"));const i={public_key:o.pubkey};return o.passphrase&&(i.private_key_salt=o.passphrase.salt,i.private_key_iterations=o.passphrase.iterations),{algorithm:E.MEGOLM_BACKUP_ALGORITHM,auth_data:i,recovery_key:r}},x.prototype.isKeyBackupKeyStored=async function(){return this.isSecretStored("m.megolm_backup.v1",!1)},x.prototype.createKeyBackupVersion=async function(e){if(null===this._crypto)throw new Error("End-to-end encryption disabled");const t={algorithm:e.algorithm,auth_data:e.auth_data};await this._crypto._signObject(t.auth_data),this._cryptoCallbacks.getCrossSigningKey&&this._crypto._crossSigningInfo.getId()&&await this._crypto._crossSigningInfo.signObject(t.auth_data,"master");const o=await this._http.authedRequest(void 0,"POST","/room_keys/version",void 0,t,{prefix:m.PREFIX_UNSTABLE});return await this.checkKeyBackup(),this.getKeyBackupEnabled()||I.logger.error("Key backup not usable even though we just created it"),o},x.prototype.deleteKeyBackupVersion=function(e){if(null===this._crypto)throw new Error("End-to-end encryption disabled");this._crypto.backupInfo&&this._crypto.backupInfo.version===e&&this.disableKeyBackup();const t=f.encodeUri("/room_keys/version/$version",{$version:e});return this._http.authedRequest(void 0,"DELETE",t,void 0,void 0,{prefix:m.PREFIX_UNSTABLE})},x.prototype._makeKeyBackupPath=function(e,t,o){let r;r=void 0!==t?f.encodeUri("/room_keys/keys/$roomId/$sessionId",{$roomId:e,$sessionId:t}):void 0!==e?f.encodeUri("/room_keys/keys/$roomId",{$roomId:e}):"/room_keys/keys";return{path:r,queryData:void 0===o?void 0:{version:o}}},x.prototype.sendKeyBackup=function(e,t,o,r){if(null===this._crypto)throw new Error("End-to-end encryption disabled");const n=this._makeKeyBackupPath(e,t,o);return this._http.authedRequest(void 0,"PUT",n.path,n.queryData,r,{prefix:m.PREFIX_UNSTABLE})},x.prototype.scheduleAllGroupSessionsForBackup=async function(){if(null===this._crypto)throw new Error("End-to-end encryption disabled");await this._crypto.scheduleAllGroupSessionsForBackup()},x.prototype.flagAllGroupSessionsForBackup=function(){if(null===this._crypto)throw new Error("End-to-end encryption disabled");return this._crypto.flagAllGroupSessionsForBackup()},x.prototype.isValidRecoveryKey=function(e){try{return(0,R.decodeRecoveryKey)(e),!0}catch(t){return!1}},x.prototype.keyBackupKeyFromPassword=function(e,t){return(0,b.keyFromAuthData)(t.auth_data,e)},x.prototype.keyBackupKeyFromRecoveryKey=function(e){return(0,R.decodeRecoveryKey)(e)},x.RESTORE_BACKUP_ERROR_BAD_KEY="RESTORE_BACKUP_ERROR_BAD_KEY",x.prototype.restoreKeyBackupWithPassword=async function(e,t,o,r,n){const i=await(0,b.keyFromAuthData)(r.auth_data,e);return this._restoreKeyBackup(i,t,o,r,n)},x.prototype.restoreKeyBackupWithSecretStorage=async function(e,t,o,r){const n=await this.getSecret("m.megolm_backup.v1"),i=(0,w.fixBackupKey)(n);if(i){const[e]=await this._crypto.getSecretStorageKey();await this.storeSecret("m.megolm_backup.v1",i,[e])}const s=(0,E.decodeBase64)(i||n);return this._restoreKeyBackup(s,t,o,e,r)},x.prototype.restoreKeyBackupWithRecoveryKey=function(e,t,o,r,n){const i=(0,R.decodeRecoveryKey)(e);return this._restoreKeyBackup(i,t,o,r,n)},x.prototype.restoreKeyBackupWithCache=async function(e,t,o,r){const n=await this._crypto.getSessionBackupPrivateKey();if(!n)throw new Error("Couldn't get key");return this._restoreKeyBackup(n,e,t,o,r)},x.prototype._restoreKeyBackup=function(t,o,r,n,{cacheCompleteCallback:i,progressCallback:s}={}){if(null===this._crypto)throw new Error("End-to-end encryption disabled");let c=0,a=[];const u=this._makeKeyBackupPath(o,r,n.version),d=new e.Olm.PkDecryption;let p;try{p=d.init_with_private_key(t)}catch(l){throw d.free(),l}return p!==n.auth_data.public_key?Promise.reject({errcode:x.RESTORE_BACKUP_ERROR_BAD_KEY}):(this._crypto.storeSessionBackupPrivateKey(t).catch((e=>{I.logger.warn("Error caching session backup key:",e)})).then(i),s&&s({stage:"fetch"}),this._http.authedRequest(void 0,"GET",u.path,u.queryData,void 0,{prefix:m.PREFIX_UNSTABLE}).then((e=>{if(e.rooms)for(const[t,o]of Object.entries(e.rooms)){if(!o.sessions)continue;c+=Object.keys(o.sessions).length;const e=$(o.sessions,d,t);for(const o of e)o.room_id=t,a.push(o)}else if(e.sessions)c=Object.keys(e.sessions).length,a=$(e.sessions,d,o);else{c=1;try{const t=q(e,d);t.room_id=o,t.session_id=r,a.push(t)}catch(l){I.logger.log("Failed to decrypt megolm session from backup",l)}}return this.importRoomKeys(a,{progressCallback:s,untrusted:!0,source:"backup"})})).then((()=>this._crypto.setTrustedBackupPubKey(p))).then((()=>({total:c,imported:a.length}))).finally((()=>{d.free()})))},x.prototype.deleteKeysFromBackup=function(e,t,o){if(null===this._crypto)throw new Error("End-to-end encryption disabled");const r=this._makeKeyBackupPath(e,t,o);return this._http.authedRequest(void 0,"DELETE",r.path,r.queryData,void 0,{prefix:m.PREFIX_UNSTABLE})},x.prototype.sendSharedHistoryKeys=async function(e,t){if(null===this._crypto)throw new Error("End-to-end encryption disabled");const o=this._roomList.getRoomEncryption(e);if(!o)return void I.logger.error("Unknown room.  Not sharing decryption keys");const r=await this._crypto.downloadKeys(t),n={};for(const[s,c]of Object.entries(r))n[s]=Object.values(c);const i=this._crypto._getRoomDecryptor(e,o.algorithm);i.sendSharedHistoryInboundSessions?await i.sendSharedHistoryInboundSessions(n):I.logger.warning("Algorithm does not support sharing previous keys",o.algorithm)},x.prototype.getGroup=function(e){return this.store.getGroup(e)},x.prototype.getGroups=function(){return this.store.getGroups()},x.prototype.getMediaConfig=function(e){return this._http.authedRequest(e,"GET","/config",void 0,void 0,{prefix:m.PREFIX_MEDIA_R0})},x.prototype.getRoom=function(e){return this.store.getRoom(e)},x.prototype.getRooms=function(){return this.store.getRooms()},x.prototype.getVisibleRooms=function(){const e=this.store.getRooms(),t=new Set;for(const o of e){const e=o.currentState.getStateEvents("m.room.create","");if(e){const o=e.getContent().predecessor;o&&o.room_id&&t.add(o.room_id)}}return e.filter((e=>!e.currentState.getStateEvents("m.room.tombstone","")||!t.has(e.roomId)))},x.prototype.getUser=function(e){return this.store.getUser(e)},x.prototype.getUsers=function(){return this.store.getUsers()},x.prototype.setAccountData=function(e,t,o){const r=f.encodeUri("/user/$userId/account_data/$type",{$userId:this.credentials.userId,$type:e}),n=(0,m.retryNetworkOperation)(5,(()=>this._http.authedRequest(void 0,"PUT",r,void 0,t)));return o&&n.then((e=>o(null,e)),o),n},x.prototype.getAccountData=function(e){return this.store.getAccountData(e)},x.prototype.getAccountDataFromServer=async function(e){if(this.isInitialSyncComplete()){const t=this.store.getAccountData(e);return t?t.getContent():null}const t=f.encodeUri("/user/$userId/account_data/$type",{$userId:this.credentials.userId,$type:e});try{return await this._http.authedRequest(void 0,"GET",t,void 0)}catch(o){if(o.data&&"M_NOT_FOUND"===o.data.errcode)return null;throw o}},x.prototype.getIgnoredUsers=function(){const e=this.getAccountData("m.ignored_user_list");return e&&e.getContent()&&e.getContent().ignored_users?Object.keys(e.getContent().ignored_users):[]},x.prototype.setIgnoredUsers=function(e,t){const o={ignored_users:{}};return e.map((e=>o.ignored_users[e]={})),this.setAccountData("m.ignored_user_list",o,t)},x.prototype.isUserIgnored=function(e){return-1!==this.getIgnoredUsers().indexOf(e)},x.prototype.joinRoom=function(e,t,o){if(f.isFunction(t))throw new Error("Expected 'opts' object, got function.");void 0===(t=t||{}).syncRoom&&(t.syncRoom=!0);const r=this.getRoom(e);if(r&&r.hasMembershipState(this.credentials.userId,"join"))return Promise.resolve(r);let n=Promise.resolve();t.inviteSignUrl&&(n=this._http.requestOtherUrl(void 0,"POST",t.inviteSignUrl,{mxid:this.credentials.userId}));const i={};t.viaServers&&(i.server_name=t.viaServers);const s={qsStringifyOptions:{arrayFormat:"repeat"}},c=this;return new Promise(((r,a)=>{n.then((function(t){const o={};t&&(o.third_party_signed=t);const r=f.encodeUri("/join/$roomid",{$roomid:e});return c._http.authedRequest(void 0,"POST",r,i,o,s)})).then((function(e){const o=e.room_id,r=new u.SyncApi(c,c._clientOpts).createRoom(o);return t.syncRoom,Promise.resolve(r)})).then((function(e){V(o,r,e)}),(function(e){G(o,a,e)}))}))},x.prototype.resendEvent=function(e,t){return F(t,e,d.EventStatus.SENDING),M(this,t,e)},x.prototype.cancelPendingEvent=function(e){if([d.EventStatus.QUEUED,d.EventStatus.NOT_SENT].indexOf(e.status)<0)throw new Error("cannot cancel an event with status "+e.status);this.scheduler&&this.scheduler.removeEventFromQueue(e);F(this.getRoom(e.getRoomId()),e,d.EventStatus.CANCELLED)},x.prototype.setRoomName=function(e,t,o){return this.sendStateEvent(e,"m.room.name",{name:t},void 0,o)},x.prototype.setRoomTopic=function(e,t,o){return this.sendStateEvent(e,"m.room.topic",{topic:t},void 0,o)},x.prototype.getRoomTags=function(e,t){const o=f.encodeUri("/user/$userId/rooms/$roomId/tags/",{$userId:this.credentials.userId,$roomId:e});return this._http.authedRequest(t,"GET",o,void 0)},x.prototype.setRoomTag=function(e,t,o,r){const n=f.encodeUri("/user/$userId/rooms/$roomId/tags/$tag",{$userId:this.credentials.userId,$roomId:e,$tag:t});return this._http.authedRequest(r,"PUT",n,void 0,o)},x.prototype.deleteRoomTag=function(e,t,o){const r=f.encodeUri("/user/$userId/rooms/$roomId/tags/$tag",{$userId:this.credentials.userId,$roomId:e,$tag:t});return this._http.authedRequest(o,"DELETE",r,void 0,void 0)},x.prototype.setRoomAccountData=function(e,t,o,r){const n=f.encodeUri("/user/$userId/rooms/$roomId/account_data/$type",{$userId:this.credentials.userId,$roomId:e,$type:t});return this._http.authedRequest(r,"PUT",n,void 0,o)},x.prototype.setPowerLevel=function(e,t,o,r,n){let i={users:{}};r&&"m.room.power_levels"===r.getType()&&(i=f.deepCopy(r.getContent())),i.users[t]=o;const s=f.encodeUri("/rooms/$roomId/state/m.room.power_levels",{$roomId:e});return this._http.authedRequest(n,"PUT",s,void 0,i)},x.prototype.sendEvent=function(e,t,o,r,n){return this._sendCompleteEvent(e,{type:t,content:o},r,n)},x.prototype._sendCompleteEvent=function(e,t,o,r){f.isFunction(o)&&(r=o,o=void 0),o||(o=this.makeTxnId());const n=new d.MatrixEvent(Object.assign(t,{event_id:"~"+e+":"+o,user_id:this.credentials.userId,sender:this.credentials.userId,room_id:e,origin_server_ts:(new Date).getTime()})),i=this.getRoom(e),s=n.getAssociatedId();if(s&&s.startsWith("~")){const e=i.getPendingEvents().find((e=>e.getId()===s));e.once("Event.localEventIdReplaced",(()=>{n.updateAssociatedId(e.getId())}))}const c=n.getType();return I.logger.log(`sendEvent of type ${c} in ${e} with txnId ${o}`),n.setTxnId(o),n.setStatus(d.EventStatus.SENDING),i&&i.addPendingEvent(n,o),n.status===d.EventStatus.NOT_SENT?Promise.reject(new Error("Event blocked by other events not yet sent")):M(this,i,n,r)},x.prototype.redactEvent=function(e,t,o,r){const n=("object"===typeof r?r:{}).reason,i="function"===typeof r?r:void 0;return this._sendCompleteEvent(e,{type:"m.room.redaction",content:{reason:n},redacts:t},o,i)},x.prototype.sendMessage=function(e,t,o,r){return f.isFunction(o)&&(r=o,o=void 0),this.sendEvent(e,"m.room.message",t,o,r)},x.prototype.sendTextMessage=function(e,t,o,r){const n=v.makeTextMessage(t);return this.sendMessage(e,n,o,r)},x.prototype.sendNotice=function(e,t,o,r){const n=v.makeNotice(t);return this.sendMessage(e,n,o,r)},x.prototype.sendEmoteMessage=function(e,t,o,r){const n=v.makeEmoteMessage(t);return this.sendMessage(e,n,o,r)},x.prototype.sendImageMessage=function(e,t,o,r,n){f.isFunction(r)&&(n=r,r=void 0),r||(r="Image");const i={msgtype:"m.image",url:t,info:o,body:r};return this.sendMessage(e,i,n)},x.prototype.sendStickerMessage=function(e,t,o,r,n){f.isFunction(r)&&(n=r,r=void 0),r||(r="Sticker");const i={url:t,info:o,body:r};return this.sendEvent(e,"m.sticker",i,n,void 0)},x.prototype.sendHtmlMessage=function(e,t,o,r){const n=v.makeHtmlMessage(t,o);return this.sendMessage(e,n,r)},x.prototype.sendHtmlNotice=function(e,t,o,r){const n=v.makeHtmlNotice(t,o);return this.sendMessage(e,n,r)},x.prototype.sendHtmlEmote=function(e,t,o,r){const n=v.makeHtmlEmote(t,o);return this.sendMessage(e,n,r)},x.prototype.sendReceipt=function(e,t,o,r){if("function"===typeof o&&(r=o,o={}),this.isGuest())return Promise.resolve({});const n=f.encodeUri("/rooms/$roomId/receipt/$receiptType/$eventId",{$roomId:e.getRoomId(),$receiptType:t,$eventId:e.getId()}),i=this._http.authedRequest(r,"POST",n,void 0,o||{}),s=this.getRoom(e.getRoomId());return s&&s._addLocalEchoReceipt(this.credentials.userId,e,t),i},x.prototype.sendReadReceipt=async function(e,t,o){"function"===typeof t&&(o=t,t={}),t||(t={});const r=e.getId(),n=this.getRoom(e.getRoomId());if(n&&n.hasPendingEvent(r))throw new Error(`Cannot set read receipt to a pending event (${r})`);const i={"m.hidden":Boolean(t.hidden)};return this.sendReceipt(e,"m.read",i,o)},x.prototype.setRoomReadMarkers=async function(e,t,o,r){const n=this.getRoom(e);if(n&&n.hasPendingEvent(t))throw new Error(`Cannot set read marker to a pending event (${t})`);let i;if(o){if(i=o.getId(),n&&n.hasPendingEvent(i))throw new Error(`Cannot set read receipt to a pending event (${i})`);n&&n._addLocalEchoReceipt(this.credentials.userId,o,"m.read")}return this.setRoomReadMarkersHttpRequest(e,t,i,r)},x.prototype.getUrlPreview=function(e,t,o){const r=(t=6e4*Math.floor(t/6e4))+"_"+e,n=this.urlPreviewCache[r];if(n)return o&&n.then(o).catch(o),n;const i=this._http.authedRequest(o,"GET","/preview_url",{url:e,ts:t},void 0,{prefix:m.PREFIX_MEDIA_R0});return this.urlPreviewCache[r]=i,i},x.prototype.sendTyping=function(e,t,o,r){if(this.isGuest())return Promise.resolve({});const n=f.encodeUri("/rooms/$roomId/typing/$userId",{$roomId:e,$userId:this.credentials.userId}),i={typing:t};return t&&(i.timeout=o||2e4),this._http.authedRequest(r,"PUT",n,void 0,i)},x.prototype.getRoomUpgradeHistory=function(e,t=!1){let o=this.getRoom(e);if(!o)return[];const r=[o];let n=o.currentState.getStateEvents("m.room.create","");for(;n;){I.logger.log(`Looking at ${n.getId()}`);const e=n.getContent().predecessor;if(!e||!e.room_id)break;{I.logger.log(`Looking at predecessor ${e.room_id}`);const o=this.getRoom(e.room_id);if(!o)break;if(t){const e=o.currentState.getStateEvents("m.room.tombstone","");if(!e||e.getContent().replacement_room!==o.roomId)break}r.splice(0,0,o),n=o.currentState.getStateEvents("m.room.create","")}}let i=o.currentState.getStateEvents("m.room.tombstone","");for(;i;){const e=this.getRoom(i.getContent().replacement_room);if(!e)break;if(e.roomId===o.roomId)break;if(t){if(n=e.currentState.getStateEvents("m.room.create",""),!n||!n.getContent().predecessor)break;if(n.getContent().predecessor.room_id!==o.roomId)break}r.push(e);if(new Set(r.map((e=>e.roomId))).size<r.length)return r.slice(0,r.length-1);o=e,i=o.currentState.getStateEvents("m.room.tombstone","")}return r},x.prototype.invite=function(e,t,o,r){return L(this,e,t,"invite",r,o)},x.prototype.inviteByEmail=function(e,t,o){return this.inviteByThreePid(e,"email",t,o)},x.prototype.inviteByThreePid=async function(e,t,o,r){const n=f.encodeUri("/rooms/$roomId/invite",{$roomId:e}),i=this.getIdentityServerUrl(!0);if(!i)return Promise.reject(new m.MatrixError({error:"No supplied identity server URL",errcode:"ORG.MATRIX.JSSDK_MISSING_PARAM"}));const s={id_server:i,medium:t,address:o};if(this.identityServer&&this.identityServer.getAccessToken&&await this.doesServerAcceptIdentityAccessToken()){const e=await this.identityServer.getAccessToken();e&&(s.id_access_token=e)}return this._http.authedRequest(r,"POST",n,void 0,s)},x.prototype.leave=function(e,t){return L(this,e,void 0,"leave",void 0,t)},x.prototype.leaveRoomChain=function(e,t=!0){const o=this.getRoomUpgradeHistory(e);let r=o;if(!t){r=[];for(const t of o)if(r.push(t),t.roomId===e)break}const n={},i=[],s=e=>this.leave(e).then((()=>{n[e]=null})).catch((t=>(n[e]=t,null)));for(const c of r)i.push(s(c.roomId));return Promise.all(i).then((()=>n))},x.prototype.ban=function(e,t,o,r){return L(this,e,t,"ban",o,r)},x.prototype.forget=function(e,t,o){void 0===t&&(t=!0);const r=L(this,e,void 0,"forget",void 0,o);if(!t)return r;const n=this;return r.then((function(t){return n.store.removeRoom(e),n.emit("deleteRoom",e),t}))},x.prototype.unban=function(e,t,o){const r=f.encodeUri("/rooms/$roomId/unban",{$roomId:e}),n={user_id:t};return this._http.authedRequest(o,"POST",r,void 0,n)},x.prototype.kick=function(e,t,o,r){return function(e,t,o,r,n,i){f.isFunction(n)&&(i=n,n=void 0);const s=f.encodeUri("/rooms/$roomId/state/m.room.member/$userId",{$roomId:t,$userId:o});return e._http.authedRequest(i,"PUT",s,void 0,{membership:r,reason:n})}(this,e,t,"leave",o,r)},x.prototype.getPushActionsForEvent=function(e){return e.getPushActions()||e.setPushActions(this._pushProcessor.actionsForEvent(e)),e.getPushActions()},x.prototype.setProfileInfo=function(e,t,o){const r=f.encodeUri("/profile/$userId/$info",{$userId:this.credentials.userId,$info:e});return this._http.authedRequest(o,"PUT",r,void 0,t)},x.prototype.setDisplayName=async function(e,t){const o=await this.setProfileInfo("displayname",{displayname:e},t),r=this.getUser(this.getUserId());return r&&(r.displayName=e,r.emit("User.displayName",r.events.presence,r)),o},x.prototype.setAvatarUrl=async function(e,t){const o=await this.setProfileInfo("avatar_url",{avatar_url:e},t),r=this.getUser(this.getUserId());return r&&(r.avatarUrl=e,r.emit("User.avatarUrl",r.events.presence,r)),o},x.prototype.mxcUrlToHttp=function(e,t,o,r,n){return(0,_.getHttpUriForMxc)(this.baseUrl,e,t,o,r,n)},x.prototype._unstable_setStatusMessage=function(e){const t="im.vector.user_status";return Promise.all(this.getRooms().map((o=>{const r="join"===o.getMyMembership(),n=2===o.getInvitedAndJoinedMemberCount();if(!r||!n)return Promise.resolve();return o.currentState.mayClientSendStateEvent(t,this)?this.sendStateEvent(o.roomId,t,{status:e},this.getUserId()):Promise.resolve()})))},x.prototype.setPresence=function(e,t){const o=f.encodeUri("/presence/$userId/status",{$userId:this.credentials.userId});"string"===typeof e&&(e={presence:e});if(-1==["offline","online","unavailable"].indexOf(e.presence))throw new Error("Bad presence value: "+e.presence);return this._http.authedRequest(t,"PUT",o,void 0,e)},x.prototype.getPresence=function(e,t){const o=f.encodeUri("/presence/$userId/status",{$userId:e});return this._http.authedRequest(t,"GET",o,void 0,void 0)},x.prototype.scrollback=function(e,t,o){f.isFunction(t)&&(o=t,t=void 0),t=t||30;let r=0,n=this._ongoingScrollbacks[e.roomId]||{};if(n.promise)return n.promise;if(n.errorTs){const e=Date.now()-n.errorTs;r=Math.max(3e3-e,0)}if(null===e.oldState.paginationToken)return Promise.resolve(e);const i=this.store.scrollback(e,t).length;if(i===t)return Promise.resolve(e);t-=i;const s=this,c=new Promise(((n,i)=>{(0,f.sleep)(r).then((function(){return s._createMessagesRequest(e.roomId,e.oldState.paginationToken,t,"b")})).then((function(t){const r=f.map(t.chunk,j(s));if(t.state){const o=f.map(t.state,j(s));e.currentState.setUnknownStateEvents(o)}e.addEventsToTimeline(r,!0,e.getLiveTimeline()),e.oldState.paginationToken=t.end,0===t.chunk.length&&(e.oldState.paginationToken=null),s.store.storeEvents(e,r,t.end,!0),s._ongoingScrollbacks[e.roomId]=null,V(o,n,e)}),(function(t){s._ongoingScrollbacks[e.roomId]={errorTs:Date.now()},G(o,i,t)}))}));return n={promise:c,errorTs:null},this._ongoingScrollbacks[e.roomId]=n,c},x.prototype.getEventTimeline=function(e,t){if(!this.timelineSupport)throw new Error("timeline support is disabled. Set the 'timelineSupport' parameter to true when creating MatrixClient to enable it.");if(e.getTimelineForEvent(t))return Promise.resolve(e.getTimelineForEvent(t));const o=f.encodeUri("/rooms/$roomId/context/$eventId",{$roomId:e.room.roomId,$eventId:t});let r;this._clientOpts.lazyLoadMembers&&(r={filter:JSON.stringify(a.Filter.LAZY_LOADING_MESSAGES_FILTER)});const n=this;return n._http.authedRequest(void 0,"GET",o,r).then((function(o){if(!o.event)throw new Error("'event' not in '/context' result - homeserver too old?");if(e.getTimelineForEvent(t))return e.getTimelineForEvent(t);o.events_after.reverse();const r=o.events_after.concat([o.event]).concat(o.events_before),i=f.map(r,n.getEventMapper());let s=e.getTimelineForEvent(i[0].getId());if(s){const e=f.map(o.state,n.getEventMapper());s.getState(p.EventTimeline.BACKWARDS).setUnknownStateEvents(e)}else s=e.addTimeline(),s.initialiseState(f.map(o.state,n.getEventMapper())),s.getState(p.EventTimeline.FORWARDS).paginationToken=o.end;e.addEventsToTimeline(i,!0,s,o.start);return e.getTimelineForEvent(t)||s}))},x.prototype._createMessagesRequest=function(e,t,o,r,n){const i=f.encodeUri("/rooms/$roomId/messages",{$roomId:e});void 0===o&&(o=30);const s={from:t,limit:o,dir:r};let c=null;return this._clientOpts.lazyLoadMembers&&(c=Object.assign({},a.Filter.LAZY_LOADING_MESSAGES_FILTER)),n&&(c=c||{},Object.assign(c,n.getRoomTimelineFilterComponent())),c&&(s.filter=JSON.stringify(c)),this._http.authedRequest(void 0,"GET",i,s)},x.prototype.paginateEventTimeline=function(e,t){const o=e.getTimelineSet()===this._notifTimelineSet,r=(t=t||{}).backwards||!1;if(o&&!r)throw new Error("paginateNotifTimeline can only paginate backwards");const n=r?p.EventTimeline.BACKWARDS:p.EventTimeline.FORWARDS,i=e.getPaginationToken(n);if(!i)return Promise.resolve(!1);const s=e._paginationRequests[n];if(s)return s;let c,a,u;const d=this;if(o)c="/notifications",a={limit:"limit"in t?t.limit:30,only:"highlight"},i&&"end"!==i&&(a.from=i),u=this._http.authedRequest(void 0,"GET","/notifications",a,void 0).then((function(t){const o=t.next_token,i=[];for(let e=0;e<t.notifications.length;e++){const o=t.notifications[e],r=d.getEventMapper()(o.event);r.setPushActions(P.PushProcessor.actionListToActionsObject(o.actions)),r.event.room_id=o.room_id,i[e]=r}return e.getTimelineSet().addEventsToTimeline(i,r,e,o),r&&!t.next_token&&e.setPaginationToken(null,n),!!t.next_token})).finally((function(){e._paginationRequests[n]=null})),e._paginationRequests[n]=u;else{if(!this.getRoom(e.getRoomId()))throw new Error("Unknown room "+e.getRoomId());u=this._createMessagesRequest(e.getRoomId(),i,t.limit,n,e.getFilter()),u.then((function(t){if(t.state){const o=e.getState(n),r=f.map(t.state,d.getEventMapper());o.setUnknownStateEvents(r)}const o=t.end,i=f.map(t.chunk,d.getEventMapper());return e.getTimelineSet().addEventsToTimeline(i,r,e,o),r&&t.end==t.start&&e.setPaginationToken(null,n),t.end!=t.start})).finally((function(){e._paginationRequests[n]=null})),e._paginationRequests[n]=u}return u},x.prototype.resetNotifTimelineSet=function(){this._notifTimelineSet&&this._notifTimelineSet.resetLiveTimeline("end",null)},x.prototype.peekInRoom=function(e){return this._peekSync&&this._peekSync.stopPeeking(),this._peekSync=new u.SyncApi(this,this._clientOpts),this._peekSync.peek(e)},x.prototype.stopPeeking=function(){this._peekSync&&(this._peekSync.stopPeeking(),this._peekSync=null)},x.prototype.setGuestAccess=function(e,t){const o=this.sendStateEvent(e,"m.room.guest_access",{guest_access:t.allowJoin?"can_join":"forbidden"});let r=Promise.resolve();return t.allowRead&&(r=this.sendStateEvent(e,"m.room.history_visibility",{history_visibility:"world_readable"})),Promise.all([r,o])},x.prototype.requestRegisterEmailToken=function(e,t,o,r){return this._requestTokenFromEndpoint("/register/email/requestToken",{email:e,client_secret:t,send_attempt:o,next_link:r})},x.prototype.requestRegisterMsisdnToken=function(e,t,o,r,n){return this._requestTokenFromEndpoint("/register/msisdn/requestToken",{country:e,phone_number:t,client_secret:o,send_attempt:r,next_link:n})},x.prototype.requestAdd3pidEmailToken=function(e,t,o,r){return this._requestTokenFromEndpoint("/account/3pid/email/requestToken",{email:e,client_secret:t,send_attempt:o,next_link:r})},x.prototype.requestAdd3pidMsisdnToken=function(e,t,o,r,n){return this._requestTokenFromEndpoint("/account/3pid/msisdn/requestToken",{country:e,phone_number:t,client_secret:o,send_attempt:r,next_link:n})},x.prototype.requestPasswordEmailToken=function(e,t,o,r){return this._requestTokenFromEndpoint("/account/password/email/requestToken",{email:e,client_secret:t,send_attempt:o,next_link:r})},x.prototype.requestPasswordMsisdnToken=function(e,t,o,r,n){return this._requestTokenFromEndpoint("/account/password/msisdn/requestToken",{country:e,phone_number:t,client_secret:o,send_attempt:r,next_link:n})},x.prototype._requestTokenFromEndpoint=async function(e,t){const o=Object.assign({},t);if(!(await this.doesServerSupportSeparateAddAndBind())&&this.idBaseUrl){const e=i.default.parse(this.idBaseUrl);if(!e.host)throw new Error("Invalid ID server URL: "+this.idBaseUrl);if(o.id_server=e.host,this.identityServer&&this.identityServer.getAccessToken&&await this.doesServerAcceptIdentityAccessToken()){const e=await this.identityServer.getAccessToken();e&&(o.id_access_token=e)}}return this._http.request(void 0,"POST",e,void 0,o)},x.prototype.getRoomPushRule=function(e,t){if(!this.pushRules)throw new Error("SyncApi.sync() must be done before accessing to push rules.");for(let o=0;o<this.pushRules[e].room.length;o++){const r=this.pushRules[e].room[o];if(r.rule_id===t)return r}},x.prototype.setRoomMutePushRule=function(e,t,o){const r=this;let n,i;const s=this.getRoomPushRule(e,t);if(s&&0<=s.actions.indexOf("dont_notify")&&(i=!0),o?s?i||(n=f.defer(),this.deletePushRule(e,"room",s.rule_id).then((function(){r.addPushRule(e,"room",t,{actions:["dont_notify"]}).then((function(){n.resolve()}),(function(e){n.reject(e)}))}),(function(e){n.reject(e)})),n=n.promise):n=this.addPushRule(e,"room",t,{actions:["dont_notify"]}):i&&(n=this.deletePushRule(e,"room",s.rule_id)),n)return new Promise(((e,t)=>{n.then((function(){r.getPushRules().then((function(t){r.pushRules=t,e()}),(function(e){t(e)}))}),(function(e){r.getPushRules().then((function(o){r.pushRules=o,t(e)}),(function(o){t(e)}))}))}))},x.prototype.searchMessageText=function(e,t){const o={search_term:e.query};return"keys"in e&&(o.keys=e.keys),this.search({body:{search_categories:{room_events:o}}},t)},x.prototype.searchRoomEvents=function(e){const t={search_categories:{room_events:{search_term:e.term,filter:e.filter,order_by:"recent",event_context:{before_limit:1,after_limit:1,include_profile:!0}}}},o={_query:t,results:[],highlights:[]};return this.search({body:t}).then(this._processRoomEventsSearch.bind(this,o))},x.prototype.backPaginateRoomEventsSearch=function(e){if(!e.next_batch)return Promise.reject(new Error("Cannot backpaginate event search any further"));if(e.pendingRequest)return e.pendingRequest;const t={body:e._query,next_batch:e.next_batch},o=this.search(t).then(this._processRoomEventsSearch.bind(this,e)).finally((function(){e.pendingRequest=null}));return e.pendingRequest=o,o},x.prototype._processRoomEventsSearch=function(e,t){const o=t.search_categories.room_events;e.count=o.count,e.next_batch=o.next_batch;const r={};o.highlights.forEach((function(e){r[e]=1})),e.highlights.forEach((function(e){r[e]=1})),e.highlights=Object.keys(r);for(let n=0;n<o.results.length;n++){const t=l.SearchResult.fromJson(o.results[n],this.getEventMapper());e.results.push(t)}return e},x.prototype.syncLeftRooms=function(){if(this._syncedLeftRooms)return Promise.resolve([]);if(this._syncLeftRoomsPromise)return this._syncLeftRoomsPromise;const e=this,t=new u.SyncApi(this,this._clientOpts);return this._syncLeftRoomsPromise=t.syncLeftRooms(),this._syncLeftRoomsPromise.then((function(t){I.logger.log("Marking success of sync left room request"),e._syncedLeftRooms=!0})).finally((function(){e._syncLeftRoomsPromise=null})),this._syncLeftRoomsPromise},x.prototype.createFilter=function(e){const t=this,o=f.encodeUri("/user/$userId/filter",{$userId:this.credentials.userId});return this._http.authedRequest(void 0,"POST",o,void 0,e).then((function(o){const r=a.Filter.fromJson(t.credentials.userId,o.filter_id,e);return t.store.storeFilter(r),r}))},x.prototype.getFilter=function(e,t,o){if(o){const o=this.store.getFilter(e,t);if(o)return Promise.resolve(o)}const r=this,n=f.encodeUri("/user/$userId/filter/$filterId",{$userId:e,$filterId:t});return this._http.authedRequest(void 0,"GET",n,void 0,void 0).then((function(o){const n=a.Filter.fromJson(e,t,o);return r.store.storeFilter(n),n}))},x.prototype.getOrCreateFilter=async function(e,t){const o=this.store.getFilterIdByName(e);let r;if(o){try{const e=await this.getFilter(this.credentials.userId,o,!0);if(e){const n=e.getDefinition(),i=t.getDefinition();f.deepCompare(n,i)&&(r=o)}}catch(i){if("M_UNKNOWN"!==i.errcode&&"M_NOT_FOUND"!==i.errcode)throw i}r||this.store.setFilterIdByName(e,void 0)}if(r)return r;const n=await this.createFilter(t.getDefinition());return this.store.setFilterIdByName(e,n.filterId),n.filterId},x.prototype.getOpenIdToken=function(){const e=f.encodeUri("/user/$userId/openid/request_token",{$userId:this.credentials.userId});return this._http.authedRequest(void 0,"POST",e,void 0,{})},x.prototype.turnServer=function(e){return this._http.authedRequest(e,"GET","/voip/turnServer")},x.prototype.getTurnServers=function(){return this._turnServers||[]},x.prototype.getTurnServersExpiry=function(){return this._turnServersExpiry},x.prototype._checkTurnServers=async function(){if(!this._supportsVoip)return;let t=!1;const o=this._turnServersExpiry-Date.now();if(o>A)I.logger.debug("TURN creds are valid for another "+o+" ms: not fetching new ones."),t=!0;else{I.logger.debug("Fetching new TURN credentials");try{const e=await this.turnServer();if(e.uris){I.logger.log("Got TURN URIs: "+e.uris+" refresh in "+e.ttl+" secs");const o={urls:e.uris,username:e.username,credential:e.password};this._turnServers=[o],this._turnServersExpiry=Date.now()+1e3*e.ttl,t=!0}}catch(r){I.logger.error("Failed to get TURN URIs",r),403===r.httpStatus&&(I.logger.info("TURN access unavailable for this account: stopping credentials checks"),null!==this._checkTurnServersIntervalID&&e.clearInterval(this._checkTurnServersIntervalID),this._checkTurnServersIntervalID=null)}}return t},x.prototype.setFallbackICEServerAllowed=function(e){this._fallbackICEServerAllowed=e},x.prototype.isFallbackICEServerAllowed=function(){return this._fallbackICEServerAllowed},x.prototype.isSynapseAdministrator=function(){const e=f.encodeUri("/_synapse/admin/v1/users/$userId/admin",{$userId:this.getUserId()});return this._http.authedRequest(void 0,"GET",e,void 0,void 0,{prefix:""}).then((e=>e.admin))},x.prototype.whoisSynapseUser=function(e){const t=f.encodeUri("/_synapse/admin/v1/whois/$userId",{$userId:e});return this._http.authedRequest(void 0,"GET",t,void 0,void 0,{prefix:""})},x.prototype.deactivateSynapseUser=function(e){const t=f.encodeUri("/_synapse/admin/v1/deactivate/$userId",{$userId:e});return this._http.authedRequest(void 0,"POST",t,void 0,void 0,{prefix:""})},x.prototype.startClient=async function(e){if(this.clientRunning)return;this.clientRunning=!0,"number"===typeof e&&(e={initialSyncLimit:e});const t=this.getUserId();t&&this.store.storeUser(new U.User(t)),this._crypto&&(this._crypto.uploadDeviceKeys(),this._crypto.start()),this._supportsVoip&&(this._checkTurnServersIntervalID=setInterval((()=>{this._checkTurnServers()}),A),this._checkTurnServers()),this._syncApi&&(I.logger.error("Still have sync object whilst not running: stopping old one"),this._syncApi.stop()),(e=Object.assign({},e)).crypto=this._crypto,e.canResetEntireTimeline=e=>!!this._canResetTimelineCallback&&this._canResetTimelineCallback(e),this._clientOpts=e,this._syncApi=new u.SyncApi(this,e),this._syncApi.sync(),void 0!==e.clientWellKnownPollPeriod&&(this._clientWellKnownIntervalID=setInterval((()=>{this._fetchClientWellKnown()}),1e3*e.clientWellKnownPollPeriod),this._fetchClientWellKnown())},x.prototype._fetchClientWellKnown=async function(){this._clientWellKnownPromise=C.AutoDiscovery.getRawClientConfig(this.getDomain()),this._clientWellKnown=await this._clientWellKnownPromise,this.emit("WellKnown.client",this._clientWellKnown)},x.prototype.getClientWellKnown=function(){return this._clientWellKnown},x.prototype.waitForClientWellKnown=function(){return this._clientWellKnownPromise},x.prototype._storeClientOptions=function(){const e=["boolean","string","number"],t=Object.entries(this._clientOpts).filter((([t,o])=>e.includes(typeof o))).reduce(((e,[t,o])=>(e[t]=o,e)),{});return this.store.storeClientOptions(t)},x.prototype._unstable_getSharedRooms=async function(e){if(!(await this.doesServerSupportUnstableFeature("uk.half-shot.msc2666")))throw Error("Server does not support shared_rooms API");const t=f.encodeUri("/uk.half-shot.msc2666/user/shared_rooms/$userId",{$userId:e});return(await this._http.authedRequest(void 0,"GET",t,void 0,void 0,{prefix:m.PREFIX_UNSTABLE})).joined},x.prototype.stopClient=function(){I.logger.log("stopping MatrixClient"),this.clientRunning=!1,this._syncApi&&(this._syncApi.stop(),this._syncApi=null),this._crypto&&this._crypto.stop(),this._peekSync&&this._peekSync.stopPeeking(),this._callEventHandler&&(this._callEventHandler.stop(),this._callEventHandler=null),e.clearInterval(this._checkTurnServersIntervalID),void 0!==this._clientWellKnownIntervalID&&e.clearInterval(this._clientWellKnownIntervalID)},x.prototype.getVersions=function(){return this._serverVersionsPromise||(this._serverVersionsPromise=this._http.request(void 0,"GET","/_matrix/client/versions",void 0,void 0,{prefix:""}).catch((e=>{throw this._serverVersionsPromise=null,e}))),this._serverVersionsPromise},x.prototype.isVersionSupported=async function(e){const{versions:t}=await this.getVersions();return t&&t.includes(e)},x.prototype.doesServerSupportLazyLoading=async function(){const e=await this.getVersions();if(!e)return!1;const t=e.versions,o=e.unstable_features;return t&&t.includes("r0.5.0")||o&&o["m.lazy_load_members"]},x.prototype.doesServerRequireIdServerParam=async function(){const e=await this.getVersions();if(!e)return!0;const t=e.versions;if(t&&t.includes("r0.6.0"))return!1;const o=e.unstable_features;return!o||(void 0===o["m.require_identity_server"]||o["m.require_identity_server"])},x.prototype.doesServerAcceptIdentityAccessToken=async function(){const e=await this.getVersions();if(!e)return!1;const t=e.versions,o=e.unstable_features;return t&&t.includes("r0.6.0")||o&&o["m.id_access_token"]},x.prototype.doesServerSupportSeparateAddAndBind=async function(){const e=await this.getVersions();if(!e)return!1;const t=e.versions,o=e.unstable_features;return t&&t.includes("r0.6.0")||o&&o["m.separate_add_and_bind"]},x.prototype.doesServerSupportUnstableFeature=async function(e){const t=await this.getVersions();if(!t)return!1;const o=t.unstable_features;return o&&!!o[e]},x.prototype.doesServerForceEncryptionForPreset=async function(e){const t=await this.getVersions();if(!t)return!1;const o=t.unstable_features;return o&&!!o[`io.element.e2ee_forced.${e}`]},x.prototype.hasLazyLoadMembersEnabled=function(){return!!this._clientOpts.lazyLoadMembers},x.prototype.setCanResetTimelineCallback=function(e){this._canResetTimelineCallback=e},x.prototype.getCanResetTimelineCallback=function(){return this._canResetTimelineCallback},x.prototype.relations=async function(e,t,o,r,n={}){const i=function(e,t,o){return"m.reaction"===o?o:e.isRoomEncrypted(t)?"m.room.encrypted":o}(this,e,r),s=await this.fetchRelations(e,t,o,i,n),c=this.getEventMapper();let a;s.original_event&&(a=c(s.original_event));let u=s.chunk.map(c);if("m.room.encrypted"===i){const e=a?u.concat(a):u;await Promise.all(e.map((e=>new Promise((t=>e.once("Event.decrypted",t)))))),u=u.filter((e=>e.getType()===r))}return a&&"m.replace"===o&&(u=u.filter((e=>e.getSender()===a.getSender()))),{originalEvent:a,events:u,nextBatch:s.next_batch}},x.prototype.getEventMapper=function(e){return j(this,e)},x.prototype.getCrossSigningCacheCallbacks=function(){return this._crypto&&this._crypto._crossSigningInfo.getCacheCallbacks()},x.prototype.generateClientSecret=function(){return(0,T.randomString)(32)}}).call(this,o("bqPV"))}}]);